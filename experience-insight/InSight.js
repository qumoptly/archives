/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/InSight.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/shaders/Vignette.js":
/*!*********************************!*\
  !*** ./lib/shaders/Vignette.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var glsl = __webpack_require__(/*! glslify */ \"./node_modules/glslify/browser.js\")\n\nv3d.Vignette = {\n\n\tuniforms: {\n\n\t\t\"u_color\": { value: null },\n\t\t\"u_chromatic_abberation\":   { value: 0.0 },\n\t\t\"u_texel_size\":   { value: [0.03, 0.03] },\n\t\t\"u_vignette_intensity\":   { value: 0.0 },\n\t\t\"u_red_transform\":    { value: [1.0, 0.0, 0.0, 0.0] },\n\t\t\"u_green_transform\":  { value: [0.0, 1.0, 0.0, 0.0] },\n\t\t\"u_blue_transform\":   { value: [0.0, 0.0, 1.0, 0.0] }\n\n\t},\n\n\tvertexShader: glsl([\"#define GLSLIFY 1\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n\\n  v_texcoord = uv;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n}\\n\"]),\n\tfragmentShader: glsl([\"#define GLSLIFY 1\\n//common\\nuniform sampler2D u_color;\\n\\n//chromatic abberation\\nuniform float u_chromatic_abberation;\\nuniform vec2 u_texel_size;\\n\\n//vignette\\nuniform float u_vignette_intensity;\\nuniform float u_vignette_blur;\\nuniform vec4 u_red_transform;\\nuniform vec4 u_green_transform;\\nuniform vec4 u_blue_transform;\\n\\nvarying vec2 v_texcoord;\\n\\nvoid main(void) {\\n  //common\\n  vec4 color = texture2D(u_color, v_texcoord);\\n  vec2 pos = (v_texcoord - 0.5) * 2.0;\\n\\n  //chromatic abberation\\n  vec2 green_uv = v_texcoord - u_texel_size * u_chromatic_abberation * pos * dot(pos, pos);\\n  color.g = texture2D(u_color, green_uv).g;\\n  \\n  //vignette\\n  float mask = 1.0 - dot(pos, pos) * u_vignette_intensity * 0.1;\\n  color = mask * color;\\n  color.a = 1.0;\\n  gl_FragColor = vec4(dot(color, u_red_transform), dot(color, u_green_transform), dot(color, u_blue_transform), 1.0);\\n}\\n\\n\"])\n};\n\n\n//# sourceURL=webpack:///./lib/shaders/Vignette.js?");

/***/ }),

/***/ "./node_modules/glslify/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/glslify/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(strings) {\n  if (typeof strings === 'string') strings = [strings]\n  var exprs = [].slice.call(arguments,1)\n  var parts = []\n  for (var i = 0; i < strings.length-1; i++) {\n    parts.push(strings[i], exprs[i] || '')\n  }\n  parts.push(strings[i])\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/glslify/browser.js?");

/***/ }),

/***/ "./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * perfect-scrollbar v1.4.0\n * (c) 2018 Hyunje Jun\n * @license MIT\n */\nfunction get(element) {\n  return getComputedStyle(element);\n}\n\nfunction set(element, obj) {\n  for (var key in obj) {\n    var val = obj[key];\n    if (typeof val === 'number') {\n      val = val + \"px\";\n    }\n    element.style[key] = val;\n  }\n  return element;\n}\n\nfunction div(className) {\n  var div = document.createElement('div');\n  div.className = className;\n  return div;\n}\n\nvar elMatches =\n  typeof Element !== 'undefined' &&\n  (Element.prototype.matches ||\n    Element.prototype.webkitMatchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector);\n\nfunction matches(element, query) {\n  if (!elMatches) {\n    throw new Error('No element matching method supported');\n  }\n\n  return elMatches.call(element, query);\n}\n\nfunction remove(element) {\n  if (element.remove) {\n    element.remove();\n  } else {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n}\n\nfunction queryChildren(element, selector) {\n  return Array.prototype.filter.call(element.children, function (child) { return matches(child, selector); }\n  );\n}\n\nvar cls = {\n  main: 'ps',\n  element: {\n    thumb: function (x) { return (\"ps__thumb-\" + x); },\n    rail: function (x) { return (\"ps__rail-\" + x); },\n    consuming: 'ps__child--consume',\n  },\n  state: {\n    focus: 'ps--focus',\n    clicking: 'ps--clicking',\n    active: function (x) { return (\"ps--active-\" + x); },\n    scrolling: function (x) { return (\"ps--scrolling-\" + x); },\n  },\n};\n\n/*\n * Helper methods\n */\nvar scrollingClassTimeout = { x: null, y: null };\n\nfunction addScrollingClass(i, x) {\n  var classList = i.element.classList;\n  var className = cls.state.scrolling(x);\n\n  if (classList.contains(className)) {\n    clearTimeout(scrollingClassTimeout[x]);\n  } else {\n    classList.add(className);\n  }\n}\n\nfunction removeScrollingClass(i, x) {\n  scrollingClassTimeout[x] = setTimeout(\n    function () { return i.isAlive && i.element.classList.remove(cls.state.scrolling(x)); },\n    i.settings.scrollingThreshold\n  );\n}\n\nfunction setScrollingClassInstantly(i, x) {\n  addScrollingClass(i, x);\n  removeScrollingClass(i, x);\n}\n\nvar EventElement = function EventElement(element) {\n  this.element = element;\n  this.handlers = {};\n};\n\nvar prototypeAccessors = { isEmpty: { configurable: true } };\n\nEventElement.prototype.bind = function bind (eventName, handler) {\n  if (typeof this.handlers[eventName] === 'undefined') {\n    this.handlers[eventName] = [];\n  }\n  this.handlers[eventName].push(handler);\n  this.element.addEventListener(eventName, handler, false);\n};\n\nEventElement.prototype.unbind = function unbind (eventName, target) {\n    var this$1 = this;\n\n  this.handlers[eventName] = this.handlers[eventName].filter(function (handler) {\n    if (target && handler !== target) {\n      return true;\n    }\n    this$1.element.removeEventListener(eventName, handler, false);\n    return false;\n  });\n};\n\nEventElement.prototype.unbindAll = function unbindAll () {\n    var this$1 = this;\n\n  for (var name in this$1.handlers) {\n    this$1.unbind(name);\n  }\n};\n\nprototypeAccessors.isEmpty.get = function () {\n    var this$1 = this;\n\n  return Object.keys(this.handlers).every(\n    function (key) { return this$1.handlers[key].length === 0; }\n  );\n};\n\nObject.defineProperties( EventElement.prototype, prototypeAccessors );\n\nvar EventManager = function EventManager() {\n  this.eventElements = [];\n};\n\nEventManager.prototype.eventElement = function eventElement (element) {\n  var ee = this.eventElements.filter(function (ee) { return ee.element === element; })[0];\n  if (!ee) {\n    ee = new EventElement(element);\n    this.eventElements.push(ee);\n  }\n  return ee;\n};\n\nEventManager.prototype.bind = function bind (element, eventName, handler) {\n  this.eventElement(element).bind(eventName, handler);\n};\n\nEventManager.prototype.unbind = function unbind (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  ee.unbind(eventName, handler);\n\n  if (ee.isEmpty) {\n    // remove\n    this.eventElements.splice(this.eventElements.indexOf(ee), 1);\n  }\n};\n\nEventManager.prototype.unbindAll = function unbindAll () {\n  this.eventElements.forEach(function (e) { return e.unbindAll(); });\n  this.eventElements = [];\n};\n\nEventManager.prototype.once = function once (element, eventName, handler) {\n  var ee = this.eventElement(element);\n  var onceHandler = function (evt) {\n    ee.unbind(eventName, onceHandler);\n    handler(evt);\n  };\n  ee.bind(eventName, onceHandler);\n};\n\nfunction createEvent(name) {\n  if (typeof window.CustomEvent === 'function') {\n    return new CustomEvent(name);\n  } else {\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(name, false, false, undefined);\n    return evt;\n  }\n}\n\nvar processScrollDiff = function(\n  i,\n  axis,\n  diff,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var fields;\n  if (axis === 'top') {\n    fields = [\n      'contentHeight',\n      'containerHeight',\n      'scrollTop',\n      'y',\n      'up',\n      'down' ];\n  } else if (axis === 'left') {\n    fields = [\n      'contentWidth',\n      'containerWidth',\n      'scrollLeft',\n      'x',\n      'left',\n      'right' ];\n  } else {\n    throw new Error('A proper axis should be provided');\n  }\n\n  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);\n};\n\nfunction processScrollDiff$1(\n  i,\n  diff,\n  ref,\n  useScrollingClass,\n  forceFireReachEvent\n) {\n  var contentHeight = ref[0];\n  var containerHeight = ref[1];\n  var scrollTop = ref[2];\n  var y = ref[3];\n  var up = ref[4];\n  var down = ref[5];\n  if ( useScrollingClass === void 0 ) useScrollingClass = true;\n  if ( forceFireReachEvent === void 0 ) forceFireReachEvent = false;\n\n  var element = i.element;\n\n  // reset reach\n  i.reach[y] = null;\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] < 1) {\n    i.reach[y] = 'start';\n  }\n\n  // 1 for subpixel rounding\n  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {\n    i.reach[y] = 'end';\n  }\n\n  if (diff) {\n    element.dispatchEvent(createEvent((\"ps-scroll-\" + y)));\n\n    if (diff < 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + up)));\n    } else if (diff > 0) {\n      element.dispatchEvent(createEvent((\"ps-scroll-\" + down)));\n    }\n\n    if (useScrollingClass) {\n      setScrollingClassInstantly(i, y);\n    }\n  }\n\n  if (i.reach[y] && (diff || forceFireReachEvent)) {\n    element.dispatchEvent(createEvent((\"ps-\" + y + \"-reach-\" + (i.reach[y]))));\n  }\n}\n\nfunction toInt(x) {\n  return parseInt(x, 10) || 0;\n}\n\nfunction isEditable(el) {\n  return (\n    matches(el, 'input,[contenteditable]') ||\n    matches(el, 'select,[contenteditable]') ||\n    matches(el, 'textarea,[contenteditable]') ||\n    matches(el, 'button,[contenteditable]')\n  );\n}\n\nfunction outerWidth(element) {\n  var styles = get(element);\n  return (\n    toInt(styles.width) +\n    toInt(styles.paddingLeft) +\n    toInt(styles.paddingRight) +\n    toInt(styles.borderLeftWidth) +\n    toInt(styles.borderRightWidth)\n  );\n}\n\nvar env = {\n  isWebKit:\n    typeof document !== 'undefined' &&\n    'WebkitAppearance' in document.documentElement.style,\n  supportsTouch:\n    typeof window !== 'undefined' &&\n    ('ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch)),\n  supportsIePointer:\n    typeof navigator !== 'undefined' && navigator.msMaxTouchPoints,\n  isChrome:\n    typeof navigator !== 'undefined' &&\n    /Chrome/i.test(navigator && navigator.userAgent),\n};\n\nvar updateGeometry = function(i) {\n  var element = i.element;\n  var roundedScrollTop = Math.floor(element.scrollTop);\n\n  i.containerWidth = element.clientWidth;\n  i.containerHeight = element.clientHeight;\n  i.contentWidth = element.scrollWidth;\n  i.contentHeight = element.scrollHeight;\n\n  if (!element.contains(i.scrollbarXRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('x')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarXRail);\n  }\n  if (!element.contains(i.scrollbarYRail)) {\n    // clean up and append\n    queryChildren(element, cls.element.rail('y')).forEach(function (el) { return remove(el); }\n    );\n    element.appendChild(i.scrollbarYRail);\n  }\n\n  if (\n    !i.settings.suppressScrollX &&\n    i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth\n  ) {\n    i.scrollbarXActive = true;\n    i.railXWidth = i.containerWidth - i.railXMarginWidth;\n    i.railXRatio = i.containerWidth / i.railXWidth;\n    i.scrollbarXWidth = getThumbSize(\n      i,\n      toInt(i.railXWidth * i.containerWidth / i.contentWidth)\n    );\n    i.scrollbarXLeft = toInt(\n      (i.negativeScrollAdjustment + element.scrollLeft) *\n        (i.railXWidth - i.scrollbarXWidth) /\n        (i.contentWidth - i.containerWidth)\n    );\n  } else {\n    i.scrollbarXActive = false;\n  }\n\n  if (\n    !i.settings.suppressScrollY &&\n    i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight\n  ) {\n    i.scrollbarYActive = true;\n    i.railYHeight = i.containerHeight - i.railYMarginHeight;\n    i.railYRatio = i.containerHeight / i.railYHeight;\n    i.scrollbarYHeight = getThumbSize(\n      i,\n      toInt(i.railYHeight * i.containerHeight / i.contentHeight)\n    );\n    i.scrollbarYTop = toInt(\n      roundedScrollTop *\n        (i.railYHeight - i.scrollbarYHeight) /\n        (i.contentHeight - i.containerHeight)\n    );\n  } else {\n    i.scrollbarYActive = false;\n  }\n\n  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {\n    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;\n  }\n  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {\n    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;\n  }\n\n  updateCss(element, i);\n\n  if (i.scrollbarXActive) {\n    element.classList.add(cls.state.active('x'));\n  } else {\n    element.classList.remove(cls.state.active('x'));\n    i.scrollbarXWidth = 0;\n    i.scrollbarXLeft = 0;\n    element.scrollLeft = 0;\n  }\n  if (i.scrollbarYActive) {\n    element.classList.add(cls.state.active('y'));\n  } else {\n    element.classList.remove(cls.state.active('y'));\n    i.scrollbarYHeight = 0;\n    i.scrollbarYTop = 0;\n    element.scrollTop = 0;\n  }\n};\n\nfunction getThumbSize(i, thumbSize) {\n  if (i.settings.minScrollbarLength) {\n    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);\n  }\n  if (i.settings.maxScrollbarLength) {\n    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);\n  }\n  return thumbSize;\n}\n\nfunction updateCss(element, i) {\n  var xRailOffset = { width: i.railXWidth };\n  var roundedScrollTop = Math.floor(element.scrollTop);\n\n  if (i.isRtl) {\n    xRailOffset.left =\n      i.negativeScrollAdjustment +\n      element.scrollLeft +\n      i.containerWidth -\n      i.contentWidth;\n  } else {\n    xRailOffset.left = element.scrollLeft;\n  }\n  if (i.isScrollbarXUsingBottom) {\n    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;\n  } else {\n    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;\n  }\n  set(i.scrollbarXRail, xRailOffset);\n\n  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };\n  if (i.isScrollbarYUsingRight) {\n    if (i.isRtl) {\n      yRailOffset.right =\n        i.contentWidth -\n        (i.negativeScrollAdjustment + element.scrollLeft) -\n        i.scrollbarYRight -\n        i.scrollbarYOuterWidth;\n    } else {\n      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;\n    }\n  } else {\n    if (i.isRtl) {\n      yRailOffset.left =\n        i.negativeScrollAdjustment +\n        element.scrollLeft +\n        i.containerWidth * 2 -\n        i.contentWidth -\n        i.scrollbarYLeft -\n        i.scrollbarYOuterWidth;\n    } else {\n      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;\n    }\n  }\n  set(i.scrollbarYRail, yRailOffset);\n\n  set(i.scrollbarX, {\n    left: i.scrollbarXLeft,\n    width: i.scrollbarXWidth - i.railBorderXWidth,\n  });\n  set(i.scrollbarY, {\n    top: i.scrollbarYTop,\n    height: i.scrollbarYHeight - i.railBorderYWidth,\n  });\n}\n\nvar clickRail = function(i) {\n  i.event.bind(i.scrollbarY, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarYRail, 'mousedown', function (e) {\n    var positionTop =\n      e.pageY -\n      window.pageYOffset -\n      i.scrollbarYRail.getBoundingClientRect().top;\n    var direction = positionTop > i.scrollbarYTop ? 1 : -1;\n\n    i.element.scrollTop += direction * i.containerHeight;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n\n  i.event.bind(i.scrollbarX, 'mousedown', function (e) { return e.stopPropagation(); });\n  i.event.bind(i.scrollbarXRail, 'mousedown', function (e) {\n    var positionLeft =\n      e.pageX -\n      window.pageXOffset -\n      i.scrollbarXRail.getBoundingClientRect().left;\n    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;\n\n    i.element.scrollLeft += direction * i.containerWidth;\n    updateGeometry(i);\n\n    e.stopPropagation();\n  });\n};\n\nvar dragThumb = function(i) {\n  bindMouseScrollHandler(i, [\n    'containerWidth',\n    'contentWidth',\n    'pageX',\n    'railXWidth',\n    'scrollbarX',\n    'scrollbarXWidth',\n    'scrollLeft',\n    'x',\n    'scrollbarXRail' ]);\n  bindMouseScrollHandler(i, [\n    'containerHeight',\n    'contentHeight',\n    'pageY',\n    'railYHeight',\n    'scrollbarY',\n    'scrollbarYHeight',\n    'scrollTop',\n    'y',\n    'scrollbarYRail' ]);\n};\n\nfunction bindMouseScrollHandler(\n  i,\n  ref\n) {\n  var containerHeight = ref[0];\n  var contentHeight = ref[1];\n  var pageY = ref[2];\n  var railYHeight = ref[3];\n  var scrollbarY = ref[4];\n  var scrollbarYHeight = ref[5];\n  var scrollTop = ref[6];\n  var y = ref[7];\n  var scrollbarYRail = ref[8];\n\n  var element = i.element;\n\n  var startingScrollTop = null;\n  var startingMousePageY = null;\n  var scrollBy = null;\n\n  function mouseMoveHandler(e) {\n    element[scrollTop] =\n      startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);\n    addScrollingClass(i, y);\n    updateGeometry(i);\n\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  function mouseUpHandler() {\n    removeScrollingClass(i, y);\n    i[scrollbarYRail].classList.remove(cls.state.clicking);\n    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n  }\n\n  i.event.bind(i[scrollbarY], 'mousedown', function (e) {\n    startingScrollTop = element[scrollTop];\n    startingMousePageY = e[pageY];\n    scrollBy =\n      (i[contentHeight] - i[containerHeight]) /\n      (i[railYHeight] - i[scrollbarYHeight]);\n\n    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);\n    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);\n\n    i[scrollbarYRail].classList.add(cls.state.clicking);\n\n    e.stopPropagation();\n    e.preventDefault();\n  });\n}\n\nvar keyboard = function(i) {\n  var element = i.element;\n\n  var elementHovered = function () { return matches(element, ':hover'); };\n  var scrollbarFocused = function () { return matches(i.scrollbarX, ':focus') || matches(i.scrollbarY, ':focus'); };\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    if (deltaX === 0) {\n      if (!i.scrollbarYActive) {\n        return false;\n      }\n      if (\n        (scrollTop === 0 && deltaY > 0) ||\n        (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n\n    var scrollLeft = element.scrollLeft;\n    if (deltaY === 0) {\n      if (!i.scrollbarXActive) {\n        return false;\n      }\n      if (\n        (scrollLeft === 0 && deltaX < 0) ||\n        (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)\n      ) {\n        return !i.settings.wheelPropagation;\n      }\n    }\n    return true;\n  }\n\n  i.event.bind(i.ownerDocument, 'keydown', function (e) {\n    if (\n      (e.isDefaultPrevented && e.isDefaultPrevented()) ||\n      e.defaultPrevented\n    ) {\n      return;\n    }\n\n    if (!elementHovered() && !scrollbarFocused()) {\n      return;\n    }\n\n    var activeElement = document.activeElement\n      ? document.activeElement\n      : i.ownerDocument.activeElement;\n    if (activeElement) {\n      if (activeElement.tagName === 'IFRAME') {\n        activeElement = activeElement.contentDocument.activeElement;\n      } else {\n        // go deeper if element is a webcomponent\n        while (activeElement.shadowRoot) {\n          activeElement = activeElement.shadowRoot.activeElement;\n        }\n      }\n      if (isEditable(activeElement)) {\n        return;\n      }\n    }\n\n    var deltaX = 0;\n    var deltaY = 0;\n\n    switch (e.which) {\n      case 37: // left\n        if (e.metaKey) {\n          deltaX = -i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = -i.containerWidth;\n        } else {\n          deltaX = -30;\n        }\n        break;\n      case 38: // up\n        if (e.metaKey) {\n          deltaY = i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = 30;\n        }\n        break;\n      case 39: // right\n        if (e.metaKey) {\n          deltaX = i.contentWidth;\n        } else if (e.altKey) {\n          deltaX = i.containerWidth;\n        } else {\n          deltaX = 30;\n        }\n        break;\n      case 40: // down\n        if (e.metaKey) {\n          deltaY = -i.contentHeight;\n        } else if (e.altKey) {\n          deltaY = -i.containerHeight;\n        } else {\n          deltaY = -30;\n        }\n        break;\n      case 32: // space bar\n        if (e.shiftKey) {\n          deltaY = i.containerHeight;\n        } else {\n          deltaY = -i.containerHeight;\n        }\n        break;\n      case 33: // page up\n        deltaY = i.containerHeight;\n        break;\n      case 34: // page down\n        deltaY = -i.containerHeight;\n        break;\n      case 36: // home\n        deltaY = i.contentHeight;\n        break;\n      case 35: // end\n        deltaY = -i.contentHeight;\n        break;\n      default:\n        return;\n    }\n\n    if (i.settings.suppressScrollX && deltaX !== 0) {\n      return;\n    }\n    if (i.settings.suppressScrollY && deltaY !== 0) {\n      return;\n    }\n\n    element.scrollTop -= deltaY;\n    element.scrollLeft += deltaX;\n    updateGeometry(i);\n\n    if (shouldPreventDefault(deltaX, deltaY)) {\n      e.preventDefault();\n    }\n  });\n};\n\nvar wheel = function(i) {\n  var element = i.element;\n\n  function shouldPreventDefault(deltaX, deltaY) {\n    var roundedScrollTop = Math.floor(element.scrollTop);\n    var isTop = element.scrollTop === 0;\n    var isBottom =\n      roundedScrollTop + element.offsetHeight === element.scrollHeight;\n    var isLeft = element.scrollLeft === 0;\n    var isRight =\n      element.scrollLeft + element.offsetWidth === element.scrollWidth;\n\n    var hitsBound;\n\n    // pick axis with primary direction\n    if (Math.abs(deltaY) > Math.abs(deltaX)) {\n      hitsBound = isTop || isBottom;\n    } else {\n      hitsBound = isLeft || isRight;\n    }\n\n    return hitsBound ? !i.settings.wheelPropagation : true;\n  }\n\n  function getDeltaFromEvent(e) {\n    var deltaX = e.deltaX;\n    var deltaY = -1 * e.deltaY;\n\n    if (typeof deltaX === 'undefined' || typeof deltaY === 'undefined') {\n      // OS X Safari\n      deltaX = -1 * e.wheelDeltaX / 6;\n      deltaY = e.wheelDeltaY / 6;\n    }\n\n    if (e.deltaMode && e.deltaMode === 1) {\n      // Firefox in deltaMode 1: Line scrolling\n      deltaX *= 10;\n      deltaY *= 10;\n    }\n\n    if (deltaX !== deltaX && deltaY !== deltaY /* NaN checks */) {\n      // IE in some mouse drivers\n      deltaX = 0;\n      deltaY = e.wheelDelta;\n    }\n\n    if (e.shiftKey) {\n      // reverse axis with shift key\n      return [-deltaY, -deltaX];\n    }\n    return [deltaX, deltaY];\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    // FIXME: this is a workaround for <select> issue in FF and IE #571\n    if (!env.isWebKit && element.querySelector('select:focus')) {\n      return true;\n    }\n\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n      var overflow = [style.overflow, style.overflowX, style.overflowY].join(\n        ''\n      );\n\n      // if scrollable\n      if (overflow.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            !(cursor.scrollTop === 0 && deltaY > 0) &&\n            !(cursor.scrollTop === maxScrollTop && deltaY < 0)\n          ) {\n            return true;\n          }\n        }\n        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            !(cursor.scrollLeft === 0 && deltaX < 0) &&\n            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function mousewheelHandler(e) {\n    var ref = getDeltaFromEvent(e);\n    var deltaX = ref[0];\n    var deltaY = ref[1];\n\n    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {\n      return;\n    }\n\n    var shouldPrevent = false;\n    if (!i.settings.useBothWheelAxes) {\n      // deltaX will only be used for horizontal scrolling and deltaY will\n      // only be used for vertical scrolling - this is the default\n      element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      element.scrollLeft += deltaX * i.settings.wheelSpeed;\n    } else if (i.scrollbarYActive && !i.scrollbarXActive) {\n      // only vertical scrollbar is active and useBothWheelAxes option is\n      // active, so let's scroll vertical bar using both mouse wheel axes\n      if (deltaY) {\n        element.scrollTop -= deltaY * i.settings.wheelSpeed;\n      } else {\n        element.scrollTop += deltaX * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    } else if (i.scrollbarXActive && !i.scrollbarYActive) {\n      // useBothWheelAxes and only horizontal bar is active, so use both\n      // wheel axes for horizontal bar\n      if (deltaX) {\n        element.scrollLeft += deltaX * i.settings.wheelSpeed;\n      } else {\n        element.scrollLeft -= deltaY * i.settings.wheelSpeed;\n      }\n      shouldPrevent = true;\n    }\n\n    updateGeometry(i);\n\n    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);\n    if (shouldPrevent && !e.ctrlKey) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  }\n\n  if (typeof window.onwheel !== 'undefined') {\n    i.event.bind(element, 'wheel', mousewheelHandler);\n  } else if (typeof window.onmousewheel !== 'undefined') {\n    i.event.bind(element, 'mousewheel', mousewheelHandler);\n  }\n};\n\nvar touch = function(i) {\n  if (!env.supportsTouch && !env.supportsIePointer) {\n    return;\n  }\n\n  var element = i.element;\n\n  function shouldPrevent(deltaX, deltaY) {\n    var scrollTop = Math.floor(element.scrollTop);\n    var scrollLeft = element.scrollLeft;\n    var magnitudeX = Math.abs(deltaX);\n    var magnitudeY = Math.abs(deltaY);\n\n    if (magnitudeY > magnitudeX) {\n      // user is perhaps trying to swipe up/down the page\n\n      if (\n        (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight) ||\n        (deltaY > 0 && scrollTop === 0)\n      ) {\n        // set prevent for mobile Chrome refresh\n        return window.scrollY === 0 && deltaY > 0 && env.isChrome;\n      }\n    } else if (magnitudeX > magnitudeY) {\n      // user is perhaps trying to swipe left/right across the page\n\n      if (\n        (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth) ||\n        (deltaX > 0 && scrollLeft === 0)\n      ) {\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function applyTouchMove(differenceX, differenceY) {\n    element.scrollTop -= differenceY;\n    element.scrollLeft -= differenceX;\n\n    updateGeometry(i);\n  }\n\n  var startOffset = {};\n  var startTime = 0;\n  var speed = {};\n  var easingLoop = null;\n\n  function getTouch(e) {\n    if (e.targetTouches) {\n      return e.targetTouches[0];\n    } else {\n      // Maybe IE pointer\n      return e;\n    }\n  }\n\n  function shouldHandle(e) {\n    if (e.pointerType && e.pointerType === 'pen' && e.buttons === 0) {\n      return false;\n    }\n    if (e.targetTouches && e.targetTouches.length === 1) {\n      return true;\n    }\n    if (\n      e.pointerType &&\n      e.pointerType !== 'mouse' &&\n      e.pointerType !== e.MSPOINTER_TYPE_MOUSE\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  function touchStart(e) {\n    if (!shouldHandle(e)) {\n      return;\n    }\n\n    var touch = getTouch(e);\n\n    startOffset.pageX = touch.pageX;\n    startOffset.pageY = touch.pageY;\n\n    startTime = new Date().getTime();\n\n    if (easingLoop !== null) {\n      clearInterval(easingLoop);\n    }\n  }\n\n  function shouldBeConsumedByChild(target, deltaX, deltaY) {\n    if (!element.contains(target)) {\n      return false;\n    }\n\n    var cursor = target;\n\n    while (cursor && cursor !== element) {\n      if (cursor.classList.contains(cls.element.consuming)) {\n        return true;\n      }\n\n      var style = get(cursor);\n      var overflow = [style.overflow, style.overflowX, style.overflowY].join(\n        ''\n      );\n\n      // if scrollable\n      if (overflow.match(/(scroll|auto)/)) {\n        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;\n        if (maxScrollTop > 0) {\n          if (\n            !(cursor.scrollTop === 0 && deltaY > 0) &&\n            !(cursor.scrollTop === maxScrollTop && deltaY < 0)\n          ) {\n            return true;\n          }\n        }\n        var maxScrollLeft = cursor.scrollLeft - cursor.clientWidth;\n        if (maxScrollLeft > 0) {\n          if (\n            !(cursor.scrollLeft === 0 && deltaX < 0) &&\n            !(cursor.scrollLeft === maxScrollLeft && deltaX > 0)\n          ) {\n            return true;\n          }\n        }\n      }\n\n      cursor = cursor.parentNode;\n    }\n\n    return false;\n  }\n\n  function touchMove(e) {\n    if (shouldHandle(e)) {\n      var touch = getTouch(e);\n\n      var currentOffset = { pageX: touch.pageX, pageY: touch.pageY };\n\n      var differenceX = currentOffset.pageX - startOffset.pageX;\n      var differenceY = currentOffset.pageY - startOffset.pageY;\n\n      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {\n        return;\n      }\n\n      applyTouchMove(differenceX, differenceY);\n      startOffset = currentOffset;\n\n      var currentTime = new Date().getTime();\n\n      var timeGap = currentTime - startTime;\n      if (timeGap > 0) {\n        speed.x = differenceX / timeGap;\n        speed.y = differenceY / timeGap;\n        startTime = currentTime;\n      }\n\n      if (shouldPrevent(differenceX, differenceY)) {\n        e.preventDefault();\n      }\n    }\n  }\n  function touchEnd() {\n    if (i.settings.swipeEasing) {\n      clearInterval(easingLoop);\n      easingLoop = setInterval(function() {\n        if (i.isInitialized) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (!speed.x && !speed.y) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {\n          clearInterval(easingLoop);\n          return;\n        }\n\n        applyTouchMove(speed.x * 30, speed.y * 30);\n\n        speed.x *= 0.8;\n        speed.y *= 0.8;\n      }, 10);\n    }\n  }\n\n  if (env.supportsTouch) {\n    i.event.bind(element, 'touchstart', touchStart);\n    i.event.bind(element, 'touchmove', touchMove);\n    i.event.bind(element, 'touchend', touchEnd);\n  } else if (env.supportsIePointer) {\n    if (window.PointerEvent) {\n      i.event.bind(element, 'pointerdown', touchStart);\n      i.event.bind(element, 'pointermove', touchMove);\n      i.event.bind(element, 'pointerup', touchEnd);\n    } else if (window.MSPointerEvent) {\n      i.event.bind(element, 'MSPointerDown', touchStart);\n      i.event.bind(element, 'MSPointerMove', touchMove);\n      i.event.bind(element, 'MSPointerUp', touchEnd);\n    }\n  }\n};\n\nvar defaultSettings = function () { return ({\n  handlers: ['click-rail', 'drag-thumb', 'keyboard', 'wheel', 'touch'],\n  maxScrollbarLength: null,\n  minScrollbarLength: null,\n  scrollingThreshold: 1000,\n  scrollXMarginOffset: 0,\n  scrollYMarginOffset: 0,\n  suppressScrollX: false,\n  suppressScrollY: false,\n  swipeEasing: true,\n  useBothWheelAxes: false,\n  wheelPropagation: true,\n  wheelSpeed: 1,\n}); };\n\nvar handlers = {\n  'click-rail': clickRail,\n  'drag-thumb': dragThumb,\n  keyboard: keyboard,\n  wheel: wheel,\n  touch: touch,\n};\n\nvar PerfectScrollbar = function PerfectScrollbar(element, userSettings) {\n  var this$1 = this;\n  if ( userSettings === void 0 ) userSettings = {};\n\n  if (typeof element === 'string') {\n    element = document.querySelector(element);\n  }\n\n  if (!element || !element.nodeName) {\n    throw new Error('no element is specified to initialize PerfectScrollbar');\n  }\n\n  this.element = element;\n\n  element.classList.add(cls.main);\n\n  this.settings = defaultSettings();\n  for (var key in userSettings) {\n    this$1.settings[key] = userSettings[key];\n  }\n\n  this.containerWidth = null;\n  this.containerHeight = null;\n  this.contentWidth = null;\n  this.contentHeight = null;\n\n  var focus = function () { return element.classList.add(cls.state.focus); };\n  var blur = function () { return element.classList.remove(cls.state.focus); };\n\n  this.isRtl = get(element).direction === 'rtl';\n  this.isNegativeScroll = (function () {\n    var originalScrollLeft = element.scrollLeft;\n    var result = null;\n    element.scrollLeft = -1;\n    result = element.scrollLeft < 0;\n    element.scrollLeft = originalScrollLeft;\n    return result;\n  })();\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? element.scrollWidth - element.clientWidth\n    : 0;\n  this.event = new EventManager();\n  this.ownerDocument = element.ownerDocument || document;\n\n  this.scrollbarXRail = div(cls.element.rail('x'));\n  element.appendChild(this.scrollbarXRail);\n  this.scrollbarX = div(cls.element.thumb('x'));\n  this.scrollbarXRail.appendChild(this.scrollbarX);\n  this.scrollbarX.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarX, 'focus', focus);\n  this.event.bind(this.scrollbarX, 'blur', blur);\n  this.scrollbarXActive = null;\n  this.scrollbarXWidth = null;\n  this.scrollbarXLeft = null;\n  var railXStyle = get(this.scrollbarXRail);\n  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);\n  if (isNaN(this.scrollbarXBottom)) {\n    this.isScrollbarXUsingBottom = false;\n    this.scrollbarXTop = toInt(railXStyle.top);\n  } else {\n    this.isScrollbarXUsingBottom = true;\n  }\n  this.railBorderXWidth =\n    toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);\n  // Set rail to display:block to calculate margins\n  set(this.scrollbarXRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);\n  set(this.scrollbarXRail, { display: '' });\n  this.railXWidth = null;\n  this.railXRatio = null;\n\n  this.scrollbarYRail = div(cls.element.rail('y'));\n  element.appendChild(this.scrollbarYRail);\n  this.scrollbarY = div(cls.element.thumb('y'));\n  this.scrollbarYRail.appendChild(this.scrollbarY);\n  this.scrollbarY.setAttribute('tabindex', 0);\n  this.event.bind(this.scrollbarY, 'focus', focus);\n  this.event.bind(this.scrollbarY, 'blur', blur);\n  this.scrollbarYActive = null;\n  this.scrollbarYHeight = null;\n  this.scrollbarYTop = null;\n  var railYStyle = get(this.scrollbarYRail);\n  this.scrollbarYRight = parseInt(railYStyle.right, 10);\n  if (isNaN(this.scrollbarYRight)) {\n    this.isScrollbarYUsingRight = false;\n    this.scrollbarYLeft = toInt(railYStyle.left);\n  } else {\n    this.isScrollbarYUsingRight = true;\n  }\n  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;\n  this.railBorderYWidth =\n    toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railYMarginHeight =\n    toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);\n  set(this.scrollbarYRail, { display: '' });\n  this.railYHeight = null;\n  this.railYRatio = null;\n\n  this.reach = {\n    x:\n      element.scrollLeft <= 0\n        ? 'start'\n        : element.scrollLeft >= this.contentWidth - this.containerWidth\n          ? 'end'\n          : null,\n    y:\n      element.scrollTop <= 0\n        ? 'start'\n        : element.scrollTop >= this.contentHeight - this.containerHeight\n          ? 'end'\n          : null,\n  };\n\n  this.isAlive = true;\n\n  this.settings.handlers.forEach(function (handlerName) { return handlers[handlerName](this$1); });\n\n  this.lastScrollTop = Math.floor(element.scrollTop); // for onScroll only\n  this.lastScrollLeft = element.scrollLeft; // for onScroll only\n  this.event.bind(this.element, 'scroll', function (e) { return this$1.onScroll(e); });\n  updateGeometry(this);\n};\n\nPerfectScrollbar.prototype.update = function update () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  // Recalcuate negative scrollLeft adjustment\n  this.negativeScrollAdjustment = this.isNegativeScroll\n    ? this.element.scrollWidth - this.element.clientWidth\n    : 0;\n\n  // Recalculate rail margins\n  set(this.scrollbarXRail, { display: 'block' });\n  set(this.scrollbarYRail, { display: 'block' });\n  this.railXMarginWidth =\n    toInt(get(this.scrollbarXRail).marginLeft) +\n    toInt(get(this.scrollbarXRail).marginRight);\n  this.railYMarginHeight =\n    toInt(get(this.scrollbarYRail).marginTop) +\n    toInt(get(this.scrollbarYRail).marginBottom);\n\n  // Hide scrollbars not to affect scrollWidth and scrollHeight\n  set(this.scrollbarXRail, { display: 'none' });\n  set(this.scrollbarYRail, { display: 'none' });\n\n  updateGeometry(this);\n\n  processScrollDiff(this, 'top', 0, false, true);\n  processScrollDiff(this, 'left', 0, false, true);\n\n  set(this.scrollbarXRail, { display: '' });\n  set(this.scrollbarYRail, { display: '' });\n};\n\nPerfectScrollbar.prototype.onScroll = function onScroll (e) {\n  if (!this.isAlive) {\n    return;\n  }\n\n  updateGeometry(this);\n  processScrollDiff(this, 'top', this.element.scrollTop - this.lastScrollTop);\n  processScrollDiff(\n    this,\n    'left',\n    this.element.scrollLeft - this.lastScrollLeft\n  );\n\n  this.lastScrollTop = Math.floor(this.element.scrollTop);\n  this.lastScrollLeft = this.element.scrollLeft;\n};\n\nPerfectScrollbar.prototype.destroy = function destroy () {\n  if (!this.isAlive) {\n    return;\n  }\n\n  this.event.unbindAll();\n  remove(this.scrollbarX);\n  remove(this.scrollbarY);\n  remove(this.scrollbarXRail);\n  remove(this.scrollbarYRail);\n  this.removePsClasses();\n\n  // unset elements\n  this.element = null;\n  this.scrollbarX = null;\n  this.scrollbarY = null;\n  this.scrollbarXRail = null;\n  this.scrollbarYRail = null;\n\n  this.isAlive = false;\n};\n\nPerfectScrollbar.prototype.removePsClasses = function removePsClasses () {\n  this.element.className = this.element.className\n    .split(' ')\n    .filter(function (name) { return !name.match(/^ps([-_].+|)$/); })\n    .join(' ');\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PerfectScrollbar);\n\n\n//# sourceURL=webpack:///./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js?");

/***/ }),

/***/ "./src/InSight.js":
/*!************************!*\
  !*** ./src/InSight.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_pip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/pip.js */ \"./src/pip.js\");\n/* harmony import */ var _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/collapse.js */ \"./src/collapse.js\");\n/* harmony import */ var _src_learn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/learn.js */ \"./src/learn.js\");\n/* harmony import */ var _src_manual_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/manual.js */ \"./src/manual.js\");\n/* harmony import */ var _src_animate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/animate.js */ \"./src/animate.js\");\n/* harmony import */ var perfect_scrollbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! perfect-scrollbar */ \"./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\");\n/**\n * __VERGE3D_PLAYER__ - delete this comment if you want to edit the player's code\n */\n\n\n\n\n\n\n\n\n\n\nlet getParameterByName = (name) => {\n    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);\n    return match && decodeURIComponent(match[1].replace(/\\+/g, ' '));\n}\n\nlet isEmbedded = (getParameterByName(\"embed\") === \"1\")\n\nlet learnContent = {};\nlet animationsContent = {};\n\nlet loadJSON  = (path, success, error) =>{\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function()\n    {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n            if (xhr.status === 200) {\n                if (success)\n                    success(JSON.parse(xhr.responseText));\n            } else {\n                if (error)\n                    error(xhr);\n            }\n        }\n    };\n    xhr.open(\"GET\", path, false);\n    xhr.send();\n}\nloadJSON('https://mars.nasa.gov/rss/api/?feed=experience_spacecraft&category=insight&feedtype=json',\n    function(data) {\n        // object-ify arrays\n        data.learn.forEach( (d) => { learnContent[d.id] = d } );\n        data.animations.forEach( (d) => { animationsContent[d.id] = d } );\n    },\n    function(xhr) { console.error(xhr); }\n);\n// Remove titles from our version\nif(!isEmbedded) {\n    Object.values(learnContent).forEach ( (d) => {delete d.title; } );\n    Object.values(animationsContent).forEach ( (d) => {delete d.title; } );\n}\n\n// ad hoc state for now\nwindow.animationControl = _src_animate_js__WEBPACK_IMPORTED_MODULE_4__[\"ISanimate\"].animationControl;\nlet modesById = {\n    animate: _src_animate_js__WEBPACK_IMPORTED_MODULE_4__[\"ISanimate\"],\n    manual: _src_manual_js__WEBPACK_IMPORTED_MODULE_3__[\"ISmanual\"],\n    learn: _src_learn_js__WEBPACK_IMPORTED_MODULE_2__[\"EClearn\"]\n}\nlet _tempState = {\n    mode: 'animate',\n    leftPanelInitialized: false,\n    resetAnimationOnNextAnimateMode: false\n};\nwindow.tempState = (newTempState) => {\n    if (newTempState) {\n        _tempState  = Object.assign(_tempState, newTempState);\n    }\n    else {\n        return _tempState;\n    }\n}\n\nwindow.addEventListener('load', function() {\n\nfunction V3DPlayer(containerId, ctxSettings, preloader) {\n    v3d.AppPuzzles.call(this, containerId, ctxSettings, preloader);\n}\n\nV3DPlayer.prototype = Object.assign(Object.create(v3d.AppPuzzles.prototype), {\n\n    constructor: V3DPlayer,\n\n    onLoadFinished: function(sceneLoaded, logicLoaded, editorLoaded) {\n        if (sceneLoaded) {\n            this.run();\n            initFullScreen();\n            runCode();\n        }\n    },\n});\n\nvar app = (function() {\n\n    var URL = '__URL__InSight.gltf.xz';\n    var LOGIC = '__LOGIC__visual_logic.js';\n    var PUZZLES_DIR = '../../puzzles/';\n\n    var params = v3d.AppUtils.getPageParams();\n    var url = URL.replace('__URL__', '') || params.load;\n    if (!url) {\n        console.log('No URL specified');\n        return;\n    }\n    var logicURL = params.logic || '';\n    if (!logicURL || !v3d.AppUtils.isXML(logicURL)) {\n        logicURL = LOGIC.replace('__LOGIC__', '') || logicURL;\n    }\n\n    let preloader = new v3d.Preloader();\n    preloader.onFinish = () => {\n        document.getElementById(\"preloaderContainer\").classList.add('hidden');\n        document.getElementById(\"brand\").classList.add('loaded');\n        setTimeout ( () => { _src_animate_js__WEBPACK_IMPORTED_MODULE_4__[\"ISanimate\"].activateInitialAnimation(); }, 3000);\n    };\n    preloader.onUpdate = function(percent) {\n        document.getElementById(\"progress\").style.width = percent + '%';\n    };\n    var app = new V3DPlayer('container', {preserveDrawingBuffer: true}, preloader);\n\n    prepareExternalInterface(app);\n\n    if (v3d.AppUtils.isXML(logicURL)) {\n        var logicJS = logicURL.match(/(.*)\\.xml$/)[1] + '.js';\n        app.loadSceneWithEditor(url, logicJS, PUZZLES_DIR);\n    } else if (v3d.AppUtils.isJS(logicURL)) {\n        app.loadSceneWithLogic(url, logicURL);\n    } else {\n        app.loadScene(url);\n    }\n\n    return app;\n\n})();\n\nfunction initFullScreen() {\n\n    if (document.fullscreenEnabled ||\n            document.webkitFullscreenEnabled ||\n            document.mozFullScreenEnabled ||\n            document.msFullscreenEnabled)\n        fullscreen_button.style.display = 'inline';\n\n    fullscreen_button.addEventListener('click', function(event) {\n        event.stopPropagation();\n        if (document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                document.mozFullScreenElement ||\n                document.msFullscreenElement) {\n            exitFullscreen();\n        } else\n            requestFullscreen(document.body);\n    });\n\n    function changeFullscreen() {\n        if (document.fullscreenElement ||\n                document.webkitFullscreenElement ||\n                document.mozFullScreenElement ||\n                document.msFullscreenElement)\n            fullscreen_button.className = 'fullscreen-close';\n        else\n            fullscreen_button.className = 'fullscreen-open';\n    }\n\n    document.addEventListener('webkitfullscreenchange', changeFullscreen);\n    document.addEventListener('mozfullscreenchange', changeFullscreen);\n    document.addEventListener('msfullscreenchange', changeFullscreen);\n    document.addEventListener('fullscreenchange', changeFullscreen);\n\n    function requestFullscreen(elem) {\n        if (elem.requestFullscreen)\n            elem.requestFullscreen();\n        else if (elem.mozRequestFullScreen)\n            elem.mozRequestFullScreen();\n        else if (elem.webkitRequestFullscreen)\n            elem.webkitRequestFullscreen();\n        else if (elem.msRequestFullscreen)\n            elem.msRequestFullscreen();\n    }\n\n    function exitFullscreen() {\n        if (document.exitFullscreen)\n            document.exitFullscreen();\n        else if (document.mozCancelFullScreen)\n            document.mozCancelFullScreen();\n        else if (document.webkitExitFullscreen)\n            document.webkitExitFullscreen();\n        else if (document.msExitFullscreen)\n            document.msExitFullscreen();\n    }\n}\n\nwindow.onresize = () => {\n    _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].resize();\n    _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__[\"ECcollapse\"].setup(); //Ensure the panel behavior matches screen size\n\n    //(emperical) formula to determine maximum list heights\n    document.getElementById(\"learnItems\").style.maxHeight =\n      ((window.innerHeight < 350 ? -30 : 0) + window.innerHeight * 0.3) + \"px\";\n\n\n    document.getElementById(\"replayScroll\").style.maxHeight =\n      ((window.innerHeight < 350 ? -15 : 0) + window.innerHeight * 0.3) + \"px\";\n};\n\nfunction prepareExternalInterface(app) {\n    // register functions in the app.ExternalInterface to call them from Puzzles, e.g:\n    // app.ExternalInterface.myJSFunction = function() {\n    //     console.log('Hello, World!');\n    // }\n\n    app.ExternalInterface.learnAboutPart = function(partName) {\n        console.log(partName);\n        _src_learn_js__WEBPACK_IMPORTED_MODULE_2__[\"EClearn\"].setTarget(partName);\n    }\n\n    app.ExternalInterface.enablePanelGlow = function(obj) {\n        console.log(obj);\n    }\n\n    app.ExternalInterface.disablePanelGlow = function() {\n        console.log(\"DISABLE\");\n    }\n}\n\nlet screenWidth = window.innerWidth;\nlet screenHeight = window.innerHeight;\n\n\nlet aspect = 0.9;\nlet nominalPipHeight = () => {\n    let nominal = 165;\n    if(screenWidth > 1920 && screenHeight > 360)\n        nominal = parseInt(screenWidth * 0.2);\n    else if(screenWidth >= 1280 && screenHeight > 360)\n        nominal = 380;\n    else if(screenWidth >= 700)\n        nominal = 245;\n    return nominal;\n}\n\nfunction setUpEffectsForCamera(camera, renderer)\n{\n    let composer = new v3d.EffectComposer( renderer );\n    composer.addPass( new v3d.RenderPass( app.scene, camera ) );\n\n    let effect = new v3d.ShaderPass( v3d.Vignette , \"u_color\");\n    effect.renderToScreen = true;\n    composer.addPass( effect );\n\n    return composer;\n}\n\nfunction runCode() {\n    window.app = app;\n\n    //Make the mode buttons mutually exclusive\n    function makeButton(index) {\n        return function(event) {\n            var setup = function() {\n                var elements = {};\n                elements[items[index].id] = 0;\n                elements[items[index].id + \"Panel\"] = 0;\n\n                if(!items[index].classList.contains(\"inactive\"))\n                {\n                \t\tif(tempState().leftPanelInitialized) {\n\t\t\t\t\t\t\t\t\t\t\t_src_collapse_js__WEBPACK_IMPORTED_MODULE_1__[\"ECcollapse\"].toggleLeft();\n                \t\t}\n                    return;\n                }\n\n                for(var name in elements)\n                    document.getElementById(name).classList.remove(\"inactive\");\n\n                for(var item = 0; item < items.length; item++) {\n                    if(item !== index) {\n                        var elements = {};\n                        elements[items[item].id] = 0;\n                        elements[items[item].id + \"Panel\"] = 0;\n\n                        for(var name in elements)\n                            document.getElementById(name).classList.add(\"inactive\");\n                    }\n                }\n\n                _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__[\"ECcollapse\"].openLeft();\n            }\n\n            modesById[tempState().mode].exit(items[index].id);\n            tempState({mode: items[index].id});\n            modesById[tempState().mode].enter();\n            setup();\n        }\n    }\n\n    if(isEmbedded)\n    {\n        app.ExternalInterface.deployAll();\n        tempState({mode: 'learn', resetAnimationOnNextAnimateMode: true});\n    }\n\n    var items = document.getElementsByClassName(\"mainMode\");\n    for(var idx = 0; idx < items.length; idx++)\n        items[idx].addEventListener(\"click\", makeButton(idx));\n    \n    _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__[\"ECcollapse\"].init(\"leftCollapse\", \"leftPanel\", \"rightCollapse\", \"cameraButton\", \"cameras\");\n\n    let cameraIDC = app.scene.getObjectByName(\"Camera_IDC\")\n    let cameraIDC_b = app.scene.getObjectByName(\"Camera_IDC_b\") \n    let cameraICC = app.scene.getObjectByName(\"Camera_ICC\")\n\n    let pipCanvas = document.getElementById(\"rendertarget\");\n    let renderer = new v3d.WebGLRenderer({canvas: pipCanvas});\n\n    let composerIDC = setUpEffectsForCamera(cameraIDC, renderer);\n    let composerIDC_b = setUpEffectsForCamera(cameraIDC_b, renderer);\n    let composerICC = setUpEffectsForCamera(cameraICC, renderer);\n\n    _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].init(\"cameras\", pipCanvas, \"cameraText\", \"camera-arrow-left\", \"camera-arrow-right\", renderer, [{\n            name: \"Camera IDC\",\n            modes: {\n                default: {\n                    object: cameraIDC,\n                    composer: composerIDC,\n                },\n                manual: {\n                    object: cameraIDC_b,\n                    composer: composerIDC_b,\n                }\n            },\n            aspect: 1.0\n        }, {\n            name: \"Camera ICC\",\n            modes: {\n                default: {\n                    object: cameraICC,\n                    composer: composerICC\n                }\n            },\n            aspect: 1.0\n        }\n    ]);\n\n    _src_animate_js__WEBPACK_IMPORTED_MODULE_4__[\"ISanimate\"].init(animationsContent);\n    _src_animate_js__WEBPACK_IMPORTED_MODULE_4__[\"ISanimate\"].getReadyForInitialAnimation();\n    _src_learn_js__WEBPACK_IMPORTED_MODULE_2__[\"EClearn\"].init(learnContent);\n\n    items.namedItem(tempState().mode).dispatchEvent(new Event(\"click\"))\n\t\ttempState({leftPanelInitialized: true});\n\n    // info panel logic\n    new perfect_scrollbar__WEBPACK_IMPORTED_MODULE_5__[\"default\"]( document.getElementById(\"infoScroll\"),\n    {\n      suppressScrollX: true,\n      useKeyboard: false\n    });\n\n    document.getElementById(\"info_button\").addEventListener('click', function(event) {\n      document.getElementById(\"infoOverlay\").classList.add(\"draw\");\n    });\n\n    document.getElementById(\"infoClose\").addEventListener('click', function(event) {\n      document.getElementById(\"infoOverlay\").classList.remove(\"draw\");\n    });\n    \n    app.renderCallbacks.push( (dt, time) => {\n        _src_learn_js__WEBPACK_IMPORTED_MODULE_2__[\"EClearn\"].update();\n        _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].render(dt);\n    });\n\n    onresize();\n}\n\n});\n\n\n//# sourceURL=webpack:///./src/InSight.js?");

/***/ }),

/***/ "./src/anchor.js":
/*!***********************!*\
  !*** ./src/anchor.js ***!
  \***********************/
/*! exports provided: ECanchor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ECanchor\", function() { return ECanchor; });\n/* harmony import */ var perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! perfect-scrollbar */ \"./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\");\n\n\n\n\nvar ECanchor = (function(exports) {\n\n    var anchorContainer; //The HTML element that contains all 3d anchors\n    var anchorList = [];\n\n    var ps;\n\n    exports.init = function(container) {\n        anchorContainer = document.getElementById(container);\n    }\n\n    //The fake anchor update helper\n    exports.updateFake = function(anchor) {\n        // NOTE: is it required?\n        anchor.annotation.update(app.camera);\n        exports.updateAnchor(anchor);\n    }\n\n    //Sets where the fake anchor is\n    exports.setFakeTarget = function(anchor, target, title, description, offset) {\n        if((target === anchor.obj && anchor.titleText === title) || !target)\n            return;\n\n        anchor.div.classList.remove(\"hide\");\n\n        anchor.obj = target;\n        anchor.titleText = title;\n        anchor.title.innerHTML = title;\n        anchor.description.innerHTML = description;\n\n        if (offset) {\n            // TODO:\n            anchor.localOffset = offset;\n        }\n\n        var annotation = anchor.annotation;\n\n\n        //Change anchor target\n        if (annotation.parent)\n            annotation.parent.remove(annotation);\n\n        target.add(annotation);\n\n        exports.updateAnchor(anchor);\n    }\n\n    //Hide an anchor\n    exports.hide = function(anchor) {\n        anchor.hide = true;\n        exports.updateAnchor(anchor);\n    }\n\n    //Show an anchor\n    exports.show = function(anchor) {\n        anchor.hide = false;\n        exports.updateAnchor(anchor);\n    }\n\n    //Create a new anchor object\n    exports.createAnchor = function(titleText, obj, callback, param, className, enter, leave, fake, offset, container) {\n        var clickables = []; //List of parts of the anchor popup that can be clicked\n        var div = document.createElement(\"div\");\n        div.className = className || \"annotation\";\n        clickables.push(div);\n\n        //Create and attach the floating anchor divs\n        container = container || anchorContainer;\n        container.appendChild(div);\n\n        var title = document.createElement(\"p\");\n        title.innerHTML = titleText;\n        title.className = className || \"annotation\";\n        clickables.push(title);\n\n        var close = document.createElement(\"div\");\n        close.className = (className || \"annotation\") + \"Close\";\n        clickables.push(close);\n\n        var scroll = document.createElement(\"div\");\n        scroll.className = \"scroll \" + (className || \"annotation\");\n        clickables.push(scroll);\n\n        var description = scroll;\n        description.innerHTML = titleText;\n        //description.className = className || \"annotation\";\n        //clickables.push(description);\n\n        if(fake) {\n            //Fake anchors have scrollable descriptions, add these here\n            var subDiv = document.createElement(\"div\");\n            subDiv.className = (className || \"annotation\") + \"BG\";\n            div.appendChild(subDiv);\n            clickables.push(subDiv);\n\n            subDiv.appendChild(title);\n            subDiv.appendChild(close);\n            subDiv.appendChild(scroll);\n            //scroll.appendChild(description);\n\n            subDiv = document.createElement(\"div\");\n            subDiv.className = \"bottom\";\n\n            div.appendChild(subDiv);\n            var arrow = document.createElement(\"div\");\n            arrow.className = (className || \"annotation\") + \"BG\";\n            clickables.push(arrow);\n            subDiv.appendChild(arrow);\n\n            ps = new perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__[\"default\"](scroll, {\n                suppressScrollX: true,\n                useKeyboard: false\n            });\n\n\n        } else {\n            div.appendChild(description);\n        }\n\n        //Store the anchor info\n        var anchor = {\n            div: div, //The actual moving div\n            origin: 'lb', //Specify where the anchor point is in 3D\n            title: title,\n            scroll: scroll,\n            description: description,\n            obj: obj,\n            annotation: null,\n            offsetHeight: div.offsetHeight //The pixel offset for the anchor\n        };\n\n        if(callback) {\n            //Add an on-click callback if needed\n            container.addEventListener(\"click\", function(e) {\n                var found = false;\n                for(var i in clickables) {\n                    if(e.target == clickables[i])\n                        found = true;\n                }\n\n                if(!found || div.style.opacity != 1.0)\n                    return;\n\n                callback(param, anchor);\n            }, false);\n        }\n\n        //Add hover handlers\n        if(enter) {\n            div.addEventListener(\"mouseenter\", function(e) {\n                enter(param, anchor);\n            });\n        }\n\n        if(leave) {\n            div.addEventListener(\"mouseleave\", function(e) {\n                leave(param, anchor);\n            });\n        }\n\n        var annotation = new v3d.AnnotationControl(app.container);\n        anchor.annotation = annotation;\n        annotation.updatedCallback = function(x, y, isVisible) {\n            var appearance = isVisible ? \"visible\" : \"out\";\n            anchorCallback(x, y, appearance, annotation.parent);\n        }\n\n        if(fake) {\n            anchor.origin = 'cb';\n        } else {\n            obj.add(annotation);\n        }\n\n        anchorList.push(anchor);\n        return anchor;\n    }\n\n    //The callback from v3d to actually place the anchors\n    function anchorCallback(x, y, appearance, object) {\n        for(var idx in anchorList) {\n            if(anchorList[idx].obj == object)\n                var anchor = anchorList[idx];\n        }\n\n        if(!anchor)\n            return;\n\n        anchor.x = x;\n        anchor.y = y;\n        anchor.appearance = appearance;\n\n        exports.updateAnchor(anchor);\n    }\n\n    //Place and style the HTML anchor\n    exports.updateAnchor = function(anchor) {\n        if(!anchor.appearance)\n            return;\n\n        var isVisible = true;\n\n        if(anchor.hide || anchor.appearance == \"out\") {\n            anchor.div.style.visibility = \"hidden\";\n\n            if(anchor.div.children.length)\n                anchor.div.children[0].style.visibility = \"hidden\";\n\n            isVisible = false;\n\n        } else if(anchor.appearance == \"visible\") {\n            anchor.div.style.visibility = \"visible\";\n\n            if(anchor.div.children.length)\n                anchor.div.children[0].style.visibility = \"visible\";\n\n            anchor.div.style.opacity = 1.0;\n        } else {\n            anchor.div.style.visibility = \"visible\";\n            anchor.div.style.opacity = 0.1;\n\n            if(anchor.div.children.length)\n                anchor.div.children[0].style.visibility = \"visible\";\n        }\n\n        //Performance optimization\n        if (!isVisible)\n            return;\n\n        if(anchor.origin === 'lb') {\n            anchor.div.style.left = anchor.x + \"px\";\n            anchor.div.style.top = (anchor.y - anchor.div.offsetHeight) + \"px\";\n        } else {\n            anchor.div.style.left = (anchor.x + 0.25 - anchor.div.offsetWidth / 2) + \"px\";\n            anchor.div.style.top = (anchor.y + 0.25 - anchor.div.offsetHeight) + \"px\";\n        }\n\n        ps.update();\n    }\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/anchor.js?");

/***/ }),

/***/ "./src/animate.js":
/*!************************!*\
  !*** ./src/animate.js ***!
  \************************/
/*! exports provided: ISanimate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ISanimate\", function() { return ISanimate; });\n/* harmony import */ var perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! perfect-scrollbar */ \"./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\");\n/* harmony import */ var _src_crossfade_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/crossfade.js */ \"./src/crossfade.js\");\n/* harmony import */ var _src_modal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/modal.js */ \"./src/modal.js\");\n/* harmony import */ var _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/uidata/animations.js */ \"./src/uidata/animations.js\");\n/* harmony import */ var _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\nlet ISanimate = (function(exports) {\n\n    var actions; //List of full action descriptions\n    var back; //HTML back button element\n    var next;\n    var caveatText; //Animation playback caveat\n    var currentAnimation = null; //The currently playing animation\n    var currentCallback = null; //The callback to call after playing animations\n    var desc; //HTML element for the animation description\n    var details; //HTML element for the action details\n    var list; //HTML element for actions list\n    var playing = false; //Flag to indicate if an animation is currently playing\n    var replay; //HTML element for the replay button\n    var deploy; //HTML element for the deploy button\n    var scroll; //HTML element for the scrollbar\n    var thumb; //HTML element for the action thumbnail\n    var title; //HTML element for the action title\n\n    let getParameterByName = (name) => {\n        var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);\n        return match && decodeURIComponent(match[1].replace(/\\+/g, ' '));\n    }\n\n    exports.init = function(animationsContent) {\n        back = document.getElementById(\"replayBack\");\n        next = document.getElementById(\"replayNext\");\n        details = document.getElementById(\"replayDescription\");\n        replay = document.getElementById(\"replayReplay\");\n        deploy = document.getElementById(\"replayDeploy\");\n        scroll = document.getElementById(\"replayScroll\");\n        thumb = document.getElementById(\"replayThumb\");\n        title = document.getElementById(\"replayTitle\");\n        desc = document.getElementById(\"replayText\");\n        list = document.getElementById(\"replayList\");\n\n        let isAnimationPlaying = false;\n        let isDoneAnimating = true;\n        let currentAnimationIndex = getParameterByName(\"animation\") || 0;\n\n        if(currentAnimationIndex === 0) {\n            replay.classList.add('hidden');\n            next.classList.add('hidden');\n            back.classList.add('hidden');\n        }\n        else\n        {\n            deploy.classList.add('hidden');\n        }\n        \n        \n        _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"].forEach ( (animation) => {\n            if( !animationsContent.hasOwnProperty(animation.descriptionName) ) \n            {\n                console.warn(\"target not found in animations content:\", animation.descriptionName);\n            }\n            animation.description = animationsContent.hasOwnProperty(animation.descriptionName) ? animationsContent[animation.descriptionName].long_caption : animation.description;\n            if (animationsContent.hasOwnProperty(animation.descriptionName)) {\n                if(animationsContent[animation.descriptionName].title)\n                  {\n                      animation.title = animationsContent[animation.descriptionName].title;\n                  }\n            }\n        });\n\n\n        let setPanelBody = () => {\n            let currentAnimation = _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex];\n\n            thumb.src = currentAnimation.thumbnail;\n            title.textContent = currentAnimation.title;\n            desc.textContent = currentAnimation.description;\n            list.classList.add('hide');\n            details.classList.remove('hide');\n\n            activateButtons();\n        }\n\n        let doneAnimating = () => {\n            activateButtons();\n            isAnimationPlaying = false;\n            isDoneAnimating = true;\n        };\n\n        let activateCurrentAnimation = () => {\n            let currentAnimation = _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex];\n    \n            setPanelBody();\n            setTimeout( () => { ps.update(); }, 1000);\n\n            if (currentAnimationIndex > 0)\n            {\n                history.replaceState({}, \"\", \"?animation=\"+currentAnimationIndex);\n            }\n            else\n            {\n                window.history.replaceState({}, \"\", \"InSight.html\")\n            }\n\n            isAnimationPlaying = true;\n            isDoneAnimating = false;\n\n            if (currentAnimation.animationName !== null) {\n                app.ExternalInterface[\"animate\" + currentAnimation.animationName]();\n            }\n            else\n            {\n                // show animated gif instead\n                _src_modal_js__WEBPACK_IMPORTED_MODULE_2__[\"ECmodal\"].show(currentAnimation.thumbnail, \"\");\n                doneAnimating();\n            }\n        }\n\n        let resetCurrentAnimation = () => {\n            let currentAnimation = _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex];\n            \n            if (currentAnimation.animationName !== null) {\n                app.ExternalInterface[\"reset\" + currentAnimation.animationName]();\n            }\n            else\n            {\n                // just bring up the animated gif again\n                _src_modal_js__WEBPACK_IMPORTED_MODULE_2__[\"ECmodal\"].show(currentAnimation.thumbnail, \"\");\n                doneAnimating();\n            }\n        }\n\n        let deactivateButtons = () => {\n            back.classList.add('deactivated');\n            replay.classList.add('deactivated');\n            next.classList.add('deactivated');\n        }\n\n        let activateButtons = () => {\n            if (currentAnimationIndex != 0)\n            {\n                back.classList.remove('deactivated');\n            }\n            else { \n                back.classList.add('deactivated');\n            }\n\n            if (currentAnimationIndex != _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"].length-1)\n            {\n                next.classList.remove('deactivated');\n            }\n            else { \n                next.classList.add('deactivated');\n            }\n        }\n\n        thumb.addEventListener('click', function(event) {\n            let currentAnimation = _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex];\n            _src_modal_js__WEBPACK_IMPORTED_MODULE_2__[\"ECmodal\"].show(currentAnimation.thumbnail, \"\");\n        });\n\n        thumb.addEventListener('click', function(event) {\n        });\n\n        back.addEventListener('click', function(event) {\n            let currentAnimation = _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex];\n            _src_crossfade_js__WEBPACK_IMPORTED_MODULE_1__[\"IScrossfade\"].crossfade( () => {\n                if (currentAnimation.animationName !== null) {\n                    resetCurrentAnimation();\n                }\n                if(currentAnimationIndex === 1)\n                {\n                    app.ExternalInterface.disableICCGlow();\n                }\n                currentAnimationIndex--;\n                resetCurrentAnimation();\n            },\n            () => {\n                activateCurrentAnimation();\n            })\n        });    \n\n        deploy.addEventListener('click', function(event) {\n            replay.classList.remove('hidden');\n            next.classList.remove('hidden');\n            back.classList.remove('hidden');\n            deploy.classList.add('hidden');\n            activateCurrentAnimation();\n        });\n\n        replay.addEventListener('click', function(event) {\n            _src_crossfade_js__WEBPACK_IMPORTED_MODULE_1__[\"IScrossfade\"].crossfade( ()=> {\n                resetCurrentAnimation();\n            },\n            () => {\n                activateCurrentAnimation();\n            })\n        });\n\n        next.addEventListener('click', function(event) {\n            if (isAnimationPlaying) {\n                _src_crossfade_js__WEBPACK_IMPORTED_MODULE_1__[\"IScrossfade\"].crossfade( ()=> {\n                    app.ExternalInterface[\"end\" + _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][currentAnimationIndex].animationName]();\n                    if(currentAnimationIndex === 1)\n                    {\n                        app.ExternalInterface.disableICCGlow();\n                    }\n                },\n                () => {\n                    currentAnimationIndex++;\n                    activateCurrentAnimation();\n                })\n            }\n            else\n            {\n                currentAnimationIndex++;\n                activateCurrentAnimation();\n            }\n        });    \n\n        \n\n        app.ExternalInterface.doneAnimating = function() {\n            doneAnimating();\n        }\n\n        animationControl = {\n          setManualAnimstate: () => {\n            app.ExternalInterface.resetToManualMode();\n          },\n          setGlobalAnimstate: () => {\n            for( var i = 0 ; i <= Math.min(currentAnimationIndex,5) ; i++)\n            {\n              app.ExternalInterface[\"end\" + _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][i].animationName]();\n            }\n          }\n        };\n        exports.animationControl = animationControl;\n\n        exports.getReadyForInitialAnimation = () => {\n            for( var i = 0 ; i <= currentAnimationIndex-1 ; i++)\n            {\n              app.ExternalInterface[\"end\" + _src_uidata_animations_js__WEBPACK_IMPORTED_MODULE_3__[\"animations\"][i].animationName]();\n            }\n        }\n\n        exports.activateInitialAnimation = () => {\n            if(currentAnimationIndex > 0) {\n                activateCurrentAnimation();\n            }\n        }\n\n        //Display the current animation and info\n        exports.enter = function() {\n            console.log(tempState());\n            if( tempState().resetAnimationOnNextAnimateMode )\n            {\n                app.ExternalInterface.resetAllAnimations();\n                tempState({resetAnimationOnNextAnimateMode: false});\n            }\n            if( !isDoneAnimating )\n            {\n                activateCurrentAnimation();\n            }\n            else\n            {\n                setPanelBody();\n            }\n            setTimeout( () => { ps.update(); }, 1000);\n        }\n\n        exports.exit = function(nextMode) {\n            if( nextMode === \"manual\" ) \n            {\n              app.ExternalInterface.doneAnimating();\n            }\n        } \n\n        window.ps = new perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__[\"default\"](scroll, {\n            suppressScrollX: true,\n            useKeyboard: false\n        });\n\n    }\n\n    console.log(exports);\n\n    return exports;\n})({})\n\n\n\n\n//# sourceURL=webpack:///./src/animate.js?");

/***/ }),

/***/ "./src/collapse.js":
/*!*************************!*\
  !*** ./src/collapse.js ***!
  \*************************/
/*! exports provided: ECcollapse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ECcollapse\", function() { return ECcollapse; });\n/* harmony import */ var _src_pip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/pip.js */ \"./src/pip.js\");\n\n\n\n\nvar ECcollapse = (function(exports) {\n    var hasInit = false; //Prevents interactions before loading is complete\n\n    var left; //HTML element for the left collapse\n    var leftPanel; //HTML element for the left panel\n    var right; //HTML element for the PIP collapse\n    var rightButton; //HTML element for the PIP button\n    var rightPanel; //HTML element for the PIP panel\n\n    var openLeft; //Function to determine what happens when the left side is opened\n    var closeLeft; //Function to determine what happens whent he left side is closed\n    var toggleLeft = function() {\n        if(leftOpen)\n            closeLeft();\n        else\n            openLeft();\n    };\n\n    var openRight; //Function to determine what happens when the right side is opened\n    var closeRight; //Function to determine what happens when the right side is closed\n    var toggleRight = function() {\n        if(rightOpen)\n            closeRight();\n        else\n            openRight();\n    };\n\n    var leftOpen = true;\n    var rightOpen = true;\n    var rightHidden = false;\n\n    var inputTrap = false; //Used to capture the first user interaction\n\n    //Helpers to call internal variable functions\n    exports.openLeft = function() {\n        openLeft();\n    }\n\n    exports.openRight = function() {\n        openRight();\n    }\n\n    exports.closeRight = function() {\n        closeRight();\n    }\n\n    exports.toggleLeft = function() {\n        toggleLeft();\n    }\n\n    exports.init = function(leftName, leftPanelName, rightName, rightButtonName, rightPanelName) {\n        left = document.getElementById(leftName);\n        leftPanel = document.getElementById(leftPanelName);\n        right = document.getElementById(rightName);\n        rightButton = document.getElementById(rightButtonName);\n        rightPanel = document.getElementById(rightPanelName);\n\n        left.addEventListener(\"click\", toggleLeft);\n        right.addEventListener(\"click\", toggleRight);\n        rightButton.addEventListener(\"click\", toggleRight);\n\n        //On very small screens the PIP stars closed\n        if(window.innerWidth < 768) {\n            rightPanel.classList.toggle(\"collapsed\");\n            rightOpen = false;\n        }\n\n        //On small screens only one panel can be open at once\n        if(window.innerWidth < 1024) {\n            var firstClick = function() {\n                leftPanel.removeEventListener(\"click\", firstClick);\n                inputTrap = true;\n            }\n\n            leftPanel.addEventListener(\"click\", firstClick);\n\n            //Also on small screens close the left panel after 2 seconds\n            setTimeout(function() {\n                if(!inputTrap)\n                    closeLeft();\n            }, 1);\n        }\n\n        //Reset state\n        hasInit = true;\n        exports.setup();\n    }\n\n    //Reset actions based on policies\n    exports.setup = function() {\n        if(!hasInit)\n            return;\n\n        //Default right open and close functions\n        openRight = function() {\n            if(!rightOpen)\n                rightPanel.classList.toggle(\"collapsed\");\n\n            _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].update_render();\n            rightOpen = true;\n        };\n\n        closeRight = function() {\n            if(rightOpen)\n                rightPanel.classList.toggle(\"collapsed\");\n\n            _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].update_render();\n            rightOpen = false;\n        };\n\n        //On small screens ensure the panels are mutually exclusive\n        if(window.innerWidth < 720) {\n            openRight = function() {\n                if(!rightOpen)\n                    rightPanel.classList.toggle(\"collapsed\");\n\n                _src_pip_js__WEBPACK_IMPORTED_MODULE_0__[\"ECpip\"].update_render();\n                if(openLeft)\n                    closeLeft();\n\n                rightOpen = true;\n            }\n        }\n\n        //Default left panel functions\n       openLeft = function() {\n            if(!leftOpen)\n                leftPanel.classList.toggle(\"collapsed\");\n\n            leftOpen = true;\n        };\n\n        closeLeft = function() {\n            if(leftOpen)\n                leftPanel.classList.toggle(\"collapsed\");\n\n            leftOpen = false;\n        };\n\n        //On small screens ensure the panels are mutually exclusive\n        if(window.innerWidth < 720) {\n            openLeft = function() {\n                if(!leftOpen)\n                    leftPanel.classList.toggle(\"collapsed\");\n\n                if(openRight)\n                    closeRight();\n\n                leftOpen = true;\n            }\n        }\n\n        //On extremely small screens hide the right panel when the left is open\n        if(window.innerHeight < 360 && window.innerWidth < 300) {\n            var oldOpenLeft = openLeft;\n            var oldCloseLeft = closeLeft;\n\n            openLeft = function(inHandler) {\n                oldOpenLeft(inHandler);\n\n                if(!rightHidden)\n                    rightPanel.classList.toggle(\"forceCollapse\");\n\n                rightHidden = true;\n            }\n\n            closeLeft = function(inHandler) {\n                oldCloseLeft(inHandler);\n\n                if(rightHidden)\n                    rightPanel.classList.toggle(\"forceCollapse\");\n\n                rightHidden = false;\n            }\n\n            if(leftOpen) {\n                if(rightOpen)\n                    closeRight();\n\n                if(!rightHidden)\n                    rightPanel.classList.toggle(\"forceCollapse\");\n\n                rightHidden = true;\n            }\n        } else if(rightHidden) {\n            rightPanel.classList.toggle(\"forceCollapse\");\n            rightHidden = false;\n        }\n\n        //Make sure we follow the rules for both panels not being open\n        if(leftOpen && rightOpen) {\n            if(window.innerWidth < 768)\n                closeLeft();\n        }\n    }\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/collapse.js?");

/***/ }),

/***/ "./src/crossfade.js":
/*!**************************!*\
  !*** ./src/crossfade.js ***!
  \**************************/
/*! exports provided: IScrossfade */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IScrossfade\", function() { return IScrossfade; });\n\n\nvar IScrossfade = (function(exports) {  \n  \n    const totalFadeTime = 1000;\n\n    exports.crossfade = function(cbDuring, cbAfter) {\n      app.ExternalInterface.prepareForFade();\n      var screenshot = new Image();\n      let dataUrl = document.getElementsByTagName(\"canvas\")[0].toDataURL();\n      document.getElementById(\"crossfadeOverlay\").style[\"background\"] = \"url(\"+dataUrl+\")\";\n//      document.getElementById(\"crossfadeOverlay\").style[\"background-color\"] = \"red\";\n      document.getElementById(\"crossfadeOverlay\").style[\"transition\"] = \"\";\n      document.getElementById(\"crossfadeOverlay\").style[\"-webkit-transition\"] = \"\";\n      document.getElementById(\"crossfadeOverlay\").style[\"opacity\"] = 1;\n      setTimeout( ()=> {\n        document.getElementById(\"crossfadeOverlay\").style[\"transition\"] = \"opacity \" + totalFadeTime + \"ms\";\n        document.getElementById(\"crossfadeOverlay\").style[\"-webkit-transition\"] = \"opacity \" + totalFadeTime + \"ms\";\n        document.getElementById(\"crossfadeOverlay\").style[\"opacity\"] = 0;\n        cbDuring();\n      }, 200);\n      setTimeout(cbAfter, totalFadeTime);\n    }\n\n    exports.totalFadeTime = totalFadeTime;\n\n    window.crossfade = exports.crossfade;\n\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/crossfade.js?");

/***/ }),

/***/ "./src/learn.js":
/*!**********************!*\
  !*** ./src/learn.js ***!
  \**********************/
/*! exports provided: EClearn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EClearn\", function() { return EClearn; });\n/* harmony import */ var perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! perfect-scrollbar */ \"./node_modules/perfect-scrollbar/dist/perfect-scrollbar.esm.js\");\n/* harmony import */ var _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/collapse.js */ \"./src/collapse.js\");\n/* harmony import */ var _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/anchor.js */ \"./src/anchor.js\");\n/* harmony import */ var _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/uidata/parts.js */ \"./src/uidata/parts.js\");\n/* harmony import */ var _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\nvar EClearn = (function(exports) {\n\n    var anchor; //Used to track the fake anchor used for learn mode\n    var annotationContainer; //HTML element with the current part annotation\n    var items = {}; //A list of all learn about items\n    var current = \"\"; //The currently selected learn about item\n    \n    var ps;\n\n\n    exports.init = function(learnContent) {\n        let container = document.getElementById(\"learnItems\");\n        annotationContainer = document.getElementById(\"annotation\");\n\n        _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].init(\"canvas3d\");\n\n        for(var target in _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"]) {\n\n            if( !learnContent.hasOwnProperty(target) ) \n            {\n                console.warn(\"target not found in learn content:\", target);\n            }\n\n            let name = _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].name;\n            if(learnContent.hasOwnProperty(target))\n            {\n                if(learnContent[target].title) {\n                    name = learnContent[target].title;\n                }\n            }\n\n            //Check for sane defaults for each item\n            items[target] = {\n                description: learnContent.hasOwnProperty(target) ? learnContent[target].long_caption : _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].description,\n                cameraTarget: _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].cameraTarget,\n                name: name,\n                anchorTarget: app.scene.getObjectByName(_src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].anchorTarget),\n                anchorOffset: _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].anchorOffset || new Float32Array(3),\n                element: makeListItem(target, name, _src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].indent,app.ExternalInterface[_src_uidata_parts_js__WEBPACK_IMPORTED_MODULE_3__[\"parts\"][target].highlightFunctionName])\n            };\n\n            //Add list elements\n            container.appendChild(items[target].element);\n        }\n\n        ps = new perfect_scrollbar__WEBPACK_IMPORTED_MODULE_0__[\"default\"](container, {\n            suppressScrollX: true,\n            useKeyboard: false\n        });\n    }\n\n    //Create a learn about list item and related mouse handlers\n    function makeListItem(target, text, indent, highlightFunction) {\n        var item = document.createElement('p');\n        item.dataset['target'] = target;\n        item.textContent = text;\n        item.classList.add('action');\n\n        if(indent)\n            item.style['padding-left'] = indent;\n\n        item.addEventListener('mouseenter', function(event) {\n            var target = event.target.dataset.target;\n            if(target in items)\n                highlightFunction()\n        });\n\n        item.addEventListener('mouseleave', function(event) {\n            if(current in items && items[current].glow)\n                highlightFunction()\n            else\n                app.ExternalInterface.removeHighlights()\n        });\n\n        item.addEventListener('click', function(event) {\n            setTarget(event.target.dataset['target']);\n        });\n\n        return item;\n    }\n\n    //Handle clicks on list items or objects on the screen\n    function setTarget(target) {\n  \n        //deal with group targets\n        if(target[0] === \"GROUP\")\n        {\n          target = target[1]\n        }\n\n        //Show the fake anchor if it was hidden\n        if(anchor)\n            anchor.div.classList.remove(\"hide\");\n\n        //Remove the old list highlight\n        if(current && current != target)\n            items[current].element.classList.remove('current');\n\n        //Set the new target if it exists\n        if(target in items) {\n            current = target;\n            items[current].element.classList.add('current');\n        } else {\n            current = \"\";\n        }\n        app.ExternalInterface.lookAtPart(items[target].cameraTarget || \"deck\");\n    }\n    exports.setTarget = setTarget;\n\n    //Determine if a learn about item was clicked\n    exports.pick = function(target) {\n        var name = target.name;\n\n        if(!(name in reverse))\n            setTarget(\"\");\n        else\n            setTarget(reverse[name]);\n    }\n\n    //Highlight list items based on roll-over\n    function setRollTarget(target) {\n        if(rollTarget === target)\n            return true;\n\n        if(rollTarget in reverse)\n            items[reverse[rollTarget]].element.classList.remove('roll');\n\n        rollTarget = target;\n        if(rollTarget in reverse) {\n            items[reverse[rollTarget]].element.classList.add('roll');\n            return true;\n        }\n    }\n\n    //Update the current anchor state\n    exports.update = function() {\n        if(current in items) {\n            if(!anchor) {\n                //If there is no anchor object create a fake anchor\n                anchor = _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].createAnchor(\"UNSET\", null, function(param, anchor) {\n                        anchor.div.classList.add(\"hide\");\n                    }, null, \"annotation\", function() {\n                    }, null, true, undefined, annotationContainer);\n            }\n\n            //Put the anchor on the screen at an offset from the target\n            _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].setFakeTarget(anchor, items[current].anchorTarget, items[current].name,\n                items[current].description, items[current].anchorOffset || new Float32Array(3));\n            _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].show(anchor);\n            _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].updateFake(anchor);\n        } else {\n            //Hide the anchor if no learn items are selected\n            if(anchor)\n                _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].hide(anchor);\n        }\n    }\n\n    //In learn mode close the PIP, enable the right glow groups, and disable any selection\n    exports.enter = function() {\n        _src_collapse_js__WEBPACK_IMPORTED_MODULE_1__[\"ECcollapse\"].closeRight();\n        app.ExternalInterface.setModeLearn();\n        setTimeout( () => { ps.update(); }, 1000);\n    }\n\n    //Exiting learn mode disable any glows and hide the anchor if it exists\n    exports.exit = function(nextMode) {\n        current = null;\n        if(anchor)\n            _src_anchor_js__WEBPACK_IMPORTED_MODULE_2__[\"ECanchor\"].hide(anchor);\n        Object.values(items).forEach ( (d) => {\n          d.element.classList.remove('current');\n        });\n        app.ExternalInterface.setModeBlank();\n    }\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/learn.js?");

/***/ }),

/***/ "./src/manual.js":
/*!***********************!*\
  !*** ./src/manual.js ***!
  \***********************/
/*! exports provided: ISmanual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ISmanual\", function() { return ISmanual; });\n/* harmony import */ var _src_crossfade_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/crossfade.js */ \"./src/crossfade.js\");\n\n\n\n\nvar ISmanual = (function(exports) {\n    exports.enter = function() {\n        _src_crossfade_js__WEBPACK_IMPORTED_MODULE_0__[\"IScrossfade\"].crossfade(()=> {\n            animationControl.setManualAnimstate();\n            app.ExternalInterface.startManualControl();\n        });\n    }\n\n    exports.exit = function() {\n        _src_crossfade_js__WEBPACK_IMPORTED_MODULE_0__[\"IScrossfade\"].crossfade( () => {\n            animationControl.setGlobalAnimstate();\n            app.ExternalInterface.exitManualControl();\n        });\n        \n    }\n\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/manual.js?");

/***/ }),

/***/ "./src/modal.js":
/*!**********************!*\
  !*** ./src/modal.js ***!
  \**********************/
/*! exports provided: ECmodal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ECmodal\", function() { return ECmodal; });\n\n\nvar ECmodal = (function(exports) {\n    var callback; //Callback for when the image modal is closed\n    var caption; //HTML caption element\n    var height; //The current image height\n    var image; //HTML image element\n    var modal; //HTML modal element\n\n    let init = function() {\n        caption = document.getElementById(\"imageCaption\");\n        image = document.getElementById(\"image\");\n        modal = document.getElementById(\"imageModal\");\n\n        //Clicking anywhere in the modal closes it\n        modal.addEventListener('click', function(event) {\n            exports.hide();\n\n            if(callback) {\n                callback();\n                callback = null;\n            }\n        });\n\n        //Make sure the image is centered correctly\n        window.addEventListener('resize', function() {\n            if(modal.offsetHeight !== height)\n                setHeight();\n        });\n\n        setHeight();\n    }\n\n    function setHeight() {\n        height = modal.offsetHeight;\n        image.style['max-height'] = (height * 0.9) + 'px';\n    }\n\n    //Show a modal with an image\n    exports.show = function(imageSrc, text) {\n        if (!modal)\n        {\n          init();\n        }\n\n        image.src = imageSrc;\n        modal.style.display = 'inline';\n        caption.innerHTML = text;\n\n        setHeight();\n    }\n\n    //Hide any current image modal with no callback\n    exports.hide = function() {\n        modal.style.display = 'none';\n    }\n\n    exports.setCallback = function(target) {\n        callback = target;\n    }\n\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/modal.js?");

/***/ }),

/***/ "./src/pip.js":
/*!********************!*\
  !*** ./src/pip.js ***!
  \********************/
/*! exports provided: ECpip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ECpip\", function() { return ECpip; });\n/* harmony import */ var _lib_shaders_Vignette_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/shaders/Vignette.js */ \"./lib/shaders/Vignette.js\");\n/* harmony import */ var _lib_shaders_Vignette_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_shaders_Vignette_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\nvar ECpip = (function(exports) {\n    var cameras; //The camera objects that can be displayed\n    var parentElement; //HTML PIP parent\n    var targetElement; //Target PIP canvas\n    var textElement; //HTML camera title\n\n    var current = -1; //The current PIP camera\n    var hidden = false; //Determines if the PIP should not be rendered\n\n    var renderer = null;\n\n    var doRender = true;\n\n    var frameCounter = -1;\n\n    exports.init = function(parentName, target, textName, left, right, _renderer, _cameras) {\n        parentElement = document.getElementById(parentName);\n        targetElement = target;\n        textElement = document.getElementById(textName);\n\n        renderer = _renderer\n        cameras = _cameras;\n\n        //Add handlers to cycle the cameras\n        right = document.getElementById(right);\n        right.onclick = function(event) {\n            if(event && event.preventDefault)\n                event.preventDefault();\n\n            if(++current >= cameras.length)\n                current = 0;\n\n            setIndex();\n        };\n\n        left = document.getElementById(left);\n        left.onclick = function(event) {\n            if(event && event.preventDefault)\n                event.preventDefault();\n\n            if(--current < 0)\n                current = cameras.length - 1;\n\n            setIndex();\n        };\n\n        right.onclick();\n    }\n\n    //Apply the current camera view\n    function setIndex() {\n        textElement.textContent = cameras[current].name;\n        exports.resize();\n    }\n\n    exports.setIndex = function(index) {\n        if(index >= 0 && index < cameras.length) {\n            current = index;\n            setTimeout(setIndex, 1);\n        }\n    }\n\n    exports.resize = function() {\n        if(!cameras || current < 0)\n            return;\n\n        //Determine the PIP size\n        if(window.innerWidth > 1920 && window.innerHeight > 360)\n            var nominal = parseInt(window.innerWidth * 0.2);\n        else if(window.innerWidth >= 1280 && window.innerHeight > 360)\n            var nominal = 380;\n        else if(window.innerWidth >= 700)\n            var nominal = 245;\n        else\n            var nominal = 165;\n\n        var vert = parseInt(nominal * cameras[current].aspect);\n\n        renderer.setSize(nominal, vert);\n        cameras[current].modes.hasOwnProperty(tempState().mode) ? cameras[current].modes[tempState().mode].composer.setSize(nominal, vert) : cameras[current].modes['default'].composer.setSize(nominal, vert);\n\n        var cam = cameras[current].modes.hasOwnProperty(tempState().mode) ? cameras[current].modes[tempState().mode].object : cameras[current].modes['default'].object;\n        //var cam = cameras[current].object;\n\n        cam.aspect = nominal/vert;\n        cam.far = 800;\n        cam.updateProjectionMatrix();\n\n        var vigElem = document.getElementById(\"vignette\");\n        vigElem.style.width = nominal + 'px';\n        vigElem.style.height = vert + 4 + 'px';\n    }\n\n    exports.render = function(elapsed) {\n        if(!doRender || !cameras || current < 0)\n            return;\n\n        //Limit FPS\n        if (++frameCounter % 3)\n            return;\n        \n        cameras[current].modes.hasOwnProperty(tempState().mode) ? cameras[current].modes[tempState().mode].composer.render(elapsed) : cameras[current].modes['default'].composer.render(elapsed);\n        //cameras[current].composer.render(elapsed);\n    }\n\n    //Enable or disable rendering based on PIP visibility\n    exports.update_render = function() {\n        if(parentElement.classList.contains(\"collapsed\"))\n            doRender = false;\n        else\n            doRender = true;\n    }\n\n    //Hide the PIP\n    exports.hide = function() {\n        if(!hidden)\n            parentElement.classList.toggle('hide');\n\n        hidden = true;\n    }\n\n    //Show the PIP\n    exports.show = function() {\n        if(hidden)\n            parentElement.classList.toggle('hide');\n\n        hidden = false;\n    }\n    return exports;\n})({});\n\n\n\n\n//# sourceURL=webpack:///./src/pip.js?");

/***/ }),

/***/ "./src/uidata/animations.js":
/*!**********************************!*\
  !*** ./src/uidata/animations.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n    animations: [\n        {\n            title: \"Solar Panels\",\n            animationName: 'Panels',\n            descriptionName: 'Panels',\n            thumbnail: \"images/final-photos/panels.jpg\",\n            description: \"The lander's two solar arrays will extend like circular wings east and west from the central deck, with a wingspan of 19 feet, 8 inches (6 meters). The lander with its solar panels deployed is about the size of a big 1960s convertible.\",\n        },\n        {\n            title: \"Instrument Context Camera\",\n            animationName: 'ICC',\n            descriptionName: 'ICC',\n            thumbnail: \"images/final-photos/icc.jpg\",\n            description: \"The lander's Instrument Context Camera (ICC), is mounted just below the deck, on the edge of the lander facing the workspace, which is the area of ground within reach of the arm.\",\n        },\n        {\n            title: \"Instrument Deployment Arm\",\n            animationName: 'Arm',\n            descriptionName: 'Arm',\n            thumbnail: \"images/final-photos/arm.jpg\",\n            description: \"In the weeks after landing, the arm will lift the seismometer, its wind-and-thermal shield and the thermal probe from the deck and place them onto the Martian surface.\",\n        },\n        {\n            title: \"SEIS Instrument\",\n            animationName: 'Seis',\n            descriptionName: 'Seis',\n            thumbnail: \"images/final-photos/seis.jpg\",\n            description: \"The Seismic Experiment for Interior Structure (SEIS), a seismometer that measures ground motions in a range of frequencies will be set directly onto the ground, connected to the lander by a flexible tether containing power and data lines. Then an additional protective cover -- the Wind and Thermal Shield -- will be placed over it.\",\n        },\n        {\n            title: \"Temperature/Wind Shield\",\n            animationName: 'Shield',\n            descriptionName: 'Shield',\n            thumbnail: \"images/final-photos/shield.jpg\",\n            description: \"Next, InSight will use the robotic arm to place the wind and thermal shield over the seismometer. With that shield in place, the mission will begin monitoring Mars for seismic activity.\",\n        },\n        {\n            title: \"HP³ Instrument\",\n            animationName: 'Hp3',\n            descriptionName: 'Hp3',\n            thumbnail: \"images/final-photos/hp3.jpg\",\n            description: \"InSight's second dedicated science instrument, the Heat Flow and Physical Properties Probe (HP<sup>3</sup>, pronounced \\\"H-P cubed\\\"), will provide the first precise determination of the amount of heat escaping from the planet's interior. InSight's robotic arm will place the instrument on the ground, where a self-hammering mechanical mole will burrow to a depth of 10 to 16 feet (3 to 5 meters) over the course of about 30 days.\",\n        },\n        {\n            title: \"HP³ Instrument\",\n            animationName: null,\n            descriptionName: 'Hp3',\n            thumbnail: \"images/final-photos/mole.gif\",\n            description: \"InSight's second dedicated science instrument, the Heat Flow and Physical Properties Probe (HP<sup>3</sup>, pronounced \\\"H-P cubed\\\"), will provide the first precise determination of the amount of heat escaping from the planet's interior. InSight's robotic arm will place the instrument on the ground, where a self-hammering mechanical mole will burrow to a depth of 10 to 16 feet (3 to 5 meters) over the course of about 30 days.\",\n        }\n    ]\n}\n\n\n//# sourceURL=webpack:///./src/uidata/animations.js?");

/***/ }),

/***/ "./src/uidata/parts.js":
/*!*****************************!*\
  !*** ./src/uidata/parts.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n    parts: {\n        \"panels\": {\n            name: \"Solar Panels\",\n            description: \"The lander will deploy two nearly circular, 10-sided solar arrays, each 7.05 feet (2.15 meters) in diameter, extending from opposite sides of the lander. The two arrays combined have almost as much surface area as a pingpong table. Before landing, these are stowed in a radially folded configuration similar to a folded fan. After they have been deployed, the lander's two arrays will together generate up to about 3,000 watt hours per Martian day.\",\n            highlightFunctionName: \"highlightSolarPanels\",\n            cameraTarget: \"deck\",\n            anchorTarget: \"location_solar_panels\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"ICC\": {\n            name: \"Instrument Context Camera\",\n            description: \"The lander's Instrument Context Camera (ICC), is mounted just below the deck, on the edge of the lander facing the workspace, which is the area of ground within reach of the arm.\",\n            highlightFunctionName: \"highlightICC\",\n            cameraTarget: \"ICC\",\n            anchorTarget: \"ICC\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n            indent: true\n        },\n        \"arm_for_glow\": {\n            name: \"Instrument Deployment Arm\",\n            description: \"The Instrument Deployment Arm (IDA) includes a grapple for grasping each piece of hardware the arm will lift. The grapple's five mechanical fingers can close around a handle that resembles a ball on top of a stem. Each of the three items the arm will lift has one of these handles. The three items are the Seismic Experiment for Interior Structure, the Heat Flow and Physical Properties Probe, and the seismometer's Wind and Thermal Shield.The arm is 7.8 feet (2.4 meters) long, with shoulder, elbow and wrist joints and four motors. The grapple is at the end of the arm. The arm-mounted camera is between the elbow and wrist.\",\n            highlightFunctionName: \"highlightArm\",\n            cameraTarget: \"arm_01_c\",\n            anchorTarget: \"arm_01_c\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"IDC\": {\n            name: \"Instrument Deployment Camera\",\n            description: \"The camera on the arm is called the Instrument Deployment Camera (IDC). The IDC's field of view is 45 degrees wide and tall. Movement of the arm is used to point the camera. The IDC will image the workspace in detail to support selection of the best specific locations for the deployed instruments. It will also image hardware to verify key steps are accomplished in the deployment process before proceeding to the next step. Pairs of images taken with this camera's position moved between the exposures can be used for stereo views to provide three-dimensional information. The camera can be pointed in any direction\",\n            highlightFunctionName: \"highlightIDC\",\n            cameraTarget: \"IDC\",\n            anchorTarget: \"IDC\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n            indent: \"1em\",\n        },\n        \"grapple\": {\n            name: \"Grapple\",\n            description: \"The Instrument Deployment Arm (IDA) includes a grapple for grasping each piece of hardware the arm will lift. The grapple's five mechanical fingers can close around a handle that resembles a ball on top of a stem. Each of the three items the arm will lift has one of these handles. The three items are the Seismic Experiment for Interior Structure, the Heat Flow and Physical Properties Probe, and the seismometer's Wind and Thermal Shield.\",\n            highlightFunctionName: \"highlightGrapple\",\n            cameraTarget: \"grapple\",\n            anchorTarget: \"grapple\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n            indent: \"1em\",\n        },\n        \"SEIS_baked\": {\n            name: \"SEIS Instrument\",\n            description: \"The Seismic Experiment for Interior Structure (SEIS), a seismometer that measures ground motions in a range of frequencies will be set directly onto the ground, connected to the lander by a flexible tether containing power and data lines. Then an additional protective cover -- the Wind and Thermal Shield -- will be placed over it.\",\n            highlightFunctionName: \"highlightSEIS\",\n            cameraTarget: \"SEIS_baked\",\n            anchorTarget: \"SEIS_baked\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"WTS_v3d_baked\": {\n            name: \"Wind and Thermal Shield\",\n            description: \"NASA’s Jet Propulsion Laboratory, Pasadena, California, made the tether and the Wind and Thermal Shield, which includes a skirt of chainmail to accommodate uneven ground beneath a rigid dome.\",\n            highlightFunctionName: \"highlightShield\",\n            cameraTarget: \"WTS_v3d_baked\",\n            anchorTarget: \"WTS_v3d_baked\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"TWINS\": {\n            name: \"Temperature/Wind Sensors\",\n            description: \"Two finger-size booms mounted on short vertical supports on InSight's deck will monitor atmospheric temperature and the direction and velocity of the wind. The booms face outward in roughly opposite sides of the lander.\",\n            highlightFunctionName: \"highlightTWINS\",\n            cameraTarget: \"TWINS\",\n            anchorTarget: \"TWINS\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"HP3_v3d_baked\": {\n            name: \"HP³ Instrument\",\n            description: \"InSight's second dedicated science instrument, the Heat Flow and Physical Properties Probe (HP<sup>3</sup>, pronounced \\\"H-P cubed\\\"), will provide the first precise determination of the amount of heat escaping from the planet's interior. InSight's robotic arm will place the instrument on the ground, where a self-hammering mechanical mole will burrow to a depth of 10 to 16 feet (3 to 5 meters) over the course of about 30 days.\",\n            highlightFunctionName: \"highlightHP3\",\n            cameraTarget: \"HP3_v3d_baked\",\n            anchorTarget: \"HP3_v3d_baked\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"RISE_antennas\": {\n            name: \"RISE Antenna\",\n            description: \"The Rotation and Interior Structure Experiment (RISE) does not have its own dedicated science instrument; instead, it uses InSight's direct radio connection with Earth to assess perturbations of Mars' rotation axis, which can provide information about the planet's core. The tools for RISE are the X-band radio on the InSight lander and the large dish antennas of NASA's Deep Space Network. The lander's radio link to Earth will provide precise tracking of the location of one site on the surface as the planet rotates, throughout the course of a full Mars year.\",\n            highlightFunctionName: \"highlightRISE\",\n            cameraTarget: \"RISE_antennas\",\n            anchorTarget: \"RISE_antennas\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"UHF_antenna\": {\n            name: \"UHF Antenna\",\n            description: \"The primary method for sending data to Earth from the landing site will be via UHF relay to an orbiter, through the lander's helical antenna. Mars Reconnaissance Orbiter and Mars Odyssey each will pass in the sky over InSight twice per Martian day. NASA's MAVEN orbiter and the European Space Agency's Trace Gas Orbiter and Mars Express can serve as backup relay assets for InSight. Orbiters will receive transmissions from InSight via UHF and relay the InSight data to Earth via X-band.\",\n            highlightFunctionName: \"highlightUHF\",\n            cameraTarget: \"UHF_antenna\",\n            anchorTarget: \"UHF_antenna\",\n            anchorOffset: new Float32Array([-1, -1.32, -1.32]),\n        },\n        \"pressure_inlet\": {\n            name: \"Pressure Inlet\",\n            description: \"InSight's atmospheric pressure sensor sits inside the lander, with access to the atmosphere via an inlet on the lander deck.\",\n            highlightFunctionName: \"highlightPressureInlet\",\n            cameraTarget: \"pressure_inlet\",\n            anchorTarget: \"pressure_inlet\",\n            anchorOffset: new Float32Array([-1, -1.32, -1]),\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/uidata/parts.js?");

/***/ })

/******/ });